module analysis/sass

imports
  analysis/-

signature 
  name resolution
    constructors
      IntT    : -> Type
      FloatT  : -> Type
      BoolT   : -> Type
      StringT : -> Type
      NullT   : -> Type
      ColourT : -> Type
      VarT    : -> Type
      ListT   : list(Type) -> Type
      LengthT : Type * string -> Type // The exp type and the unit
      // Result type * numT * lhsT * rhsT 
      // The result and num type is only used for evaluation, not type checking
      BinExpT : Type * Type * Type * Type -> Type
      
      MixinT : list(FArg) -> Type
      
      CSSAble  : -> CSSAble
      RootAble : -> RootAble
      UnRootAble : -> RootAble
      
    namespaces
      Var
      
      Function
      Mixin

      // Used to check whether mixin/function calls have the right number/named arguments
      Arg
      IArg
      ArgDefault
      IArgDefault
   
  functions
    
    typeForAddition: (Type * Type) -> Type {
      (IntT(), IntT())          -> IntT(),
      (FloatT(), FloatT())      -> FloatT(),
      (StringT(), StringT())    -> StringT(),
      (ColourT(), ColourT())    -> ColourT(),
      
      (LengthT(IntT(), u), LengthT(IntT(), u))      -> LengthT(IntT(), u),
      (LengthT(FloatT(), u), LengthT(FloatT(), u))  -> LengthT(FloatT(), u),
      (LengthT(IntT(), u), LengthT(FloatT(), u))    -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), LengthT(IntT(), u))    -> LengthT(FloatT(), u),
      
      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT(),
      
      (_, StringT()) -> StringT(),
      (StringT(), _) -> StringT()
    }
    
    typeForSubtraction: (Type * Type) -> Type {
      (IntT(), IntT())          -> IntT(),
      (FloatT(), FloatT())      -> FloatT(),
      (ColourT(), ColourT())    -> ColourT(),
      
      (LengthT(IntT(), u), LengthT(IntT(), u))      -> LengthT(IntT(), u),
      (LengthT(FloatT(), u), LengthT(FloatT(), u))  -> LengthT(FloatT(), u),
      (LengthT(IntT(), u), LengthT(FloatT(), u))    -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), LengthT(IntT(), u))    -> LengthT(FloatT(), u),

      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT()
    }
    
    typeForMultiplication: (Type * Type) -> Type {
      (IntT(), IntT())          -> IntT(),
      (FloatT(), FloatT())      -> FloatT(),
      (ColourT(), ColourT())    -> ColourT(),
      
      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT(),
      
      
      (IntT(), LengthT(IntT(), u))      -> LengthT(IntT(), u),
      (LengthT(IntT(), u), IntT())      -> LengthT(IntT(), u),
      (IntT(), LengthT(FloatT(), u))    -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), IntT())    -> LengthT(FloatT(), u),
      
      (FloatT(), LengthT(FloatT(), u))  -> LengthT(FloatT(), u),
      (LengthT(FloatT(), u), FloatT())  -> LengthT(FloatT(), u),
      (FloatT(), LengthT(IntT(), u))    -> LengthT(FloatT(), u),
      (LengthT(IntT(), u), FloatT())    -> LengthT(FloatT(), u),
      
      
      (IntT(), ColourT())     -> ColourT(),
      (FloatT(), ColourT())   -> ColourT(),
      (ColourT(), IntT())     -> ColourT(),
      (ColourT(), FloatT())   -> ColourT(),
      
      // Length expressions
      
      (LengthT(IntT(), l), LengthT(IntT(), r)) ->
        BinExpT(LengthT(LengthT(None(), l), r), IntT(), LengthT(IntT(), l), LengthT(IntT(), r)),
      (LengthT(FloatT(), l), LengthT(IntT(), r)) ->
        BinExpT(LengthT(LengthT(None(), l), r), FloatT(), LengthT(FloatT(), l), LengthT(IntT(), r)),
      (LengthT(IntT(), l), LengthT(FloatT(), r)) ->
        BinExpT(LengthT(LengthT(None(), l), r), FloatT(), LengthT(IntT(), l), LengthT(FloatT(), r)),
      (LengthT(FloatT(), l), LengthT(FloatT(), r)) ->
        BinExpT(LengthT(LengthT(None(), l), r), FloatT(), LengthT(FloatT(), l), LengthT(FloatT(), r)),
      
      (BinExpT(l, n, x, y), IntT())   -> BinExpT(l, n,        x, y),
      (BinExpT(l, _, x, y), FloatT()) -> BinExpT(l, FloatT(), x, y),
      (IntT(), BinExpT(l, n, x, y))   -> BinExpT(l, n,        x, y),
      (FloatT(), BinExpT(l, _, x, y)) -> BinExpT(l, FloatT(), x, y),
      
      (BinExpT(l, n, x, y), LengthT(IntT(), u)) ->
        BinExpT(LengthT(l, u), n,        BinExpT(l, n, x, y), LengthT(IntT(), u)),
      (BinExpT(l, n, x, y), LengthT(FloatT(), u)) ->
        BinExpT(LengthT(l, u), FloatT(), BinExpT(l, n, x, y), LengthT(FloatT(), u))
    }
    
    typeForDivision: (Type * Type) -> Type {
      (IntT(), IntT()) -> FloatT(),
      (FloatT(), IntT()) -> FloatT(),
      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), FloatT()) -> FloatT(),
      
      (ColourT(), IntT()) -> ColourT(),
      (ColourT(), FloatT()) -> ColourT(),
      (ColourT(), ColourT()) -> ColourT(),
    
      (LengthT(_, u), IntT())   -> LengthT(FloatT(), u),
      (LengthT(_, u), FloatT()) -> LengthT(FloatT(), u),
      (BinExpT(l, _, x, y), IntT())   -> BinExpT(l, FloatT(), x, y),
      (BinExpT(l, _, x, y), FloatT()) -> BinExpT(l, FloatT(), x, y),
      
      (BinExpT(_, _, LengthT(_, lU), LengthT(_, rU)), LengthT(_, lU)) -> LengthT(FloatT(), rU),
      (BinExpT(_, _, LengthT(_, lU), LengthT(_, rU)), LengthT(_, rU)) -> LengthT(FloatT(), lU)
    }
    
    typeForModulo: (Type * Type) -> Type {
      (IntT(), IntT()) -> IntT(),
      (FloatT(), IntT()) -> FloatT(),
      (IntT(), FloatT()) -> FloatT(),
      (FloatT(), FloatT()) -> FloatT(),
      
      (ColourT(), ColourT())  -> ColourT(),
      (ColourT(), IntT())     -> ColourT(),
      (ColourT(), FloatT())   -> ColourT(),
      
      (LengthT(IntT(), u), IntT())    -> LengthT(IntT(), u),
      (LengthT(FloatT(), u), IntT())  -> LengthT(FloatT(), u),
      (LengthT(_, u), FloatT())  -> LengthT(FloatT(), u),
      
      (BinExpT(l, IntT(), x, y), IntT()) -> BinExpT(l, IntT(), x, y),
      (BinExpT(l, FloatT(), x, y), IntT()) -> BinExpT(l, FloatT(), x, y),
      (BinExpT(l, _, x, y), FloatT()) -> BinExpT(l, FloatT(), x, y),
      
      (BinExpT(l, IntT(), x, y), BinExpT(_, IntT(), _, _)) -> BinExpT(l, IntT(), x, y),
      (BinExpT(l, FloatT(), x, y), BinExpT(_, IntT(), _, _)) -> BinExpT(l, IntT(), x, y),
      (BinExpT(l, _, x, y), BinExpT(_, FloatT(), _, _)) -> BinExpT(l, FloatT(), x, y)
    }
    
    rootableOr: (RootAble * RootAble) -> RootAble {
      (RootAble(), RootAble()) -> RootAble()
      , _ -> UnRootAble()
    }

name resolution
  labels
    A // Associated scope label for arguments of mixins
    G // Global scope
    P

  order 
    D < G,
    D < P,
    G < P   

  well-formedness
    P* G*

relations 
  
  /**
   *  Whether a type is coerceable to another, e.g. number to string
   */
  reflexive, symmetric, transitive coerce : Type * Type {
    LengthT(+coerce, +coerce)
  }
  
  reflexive, anti-symmetric, anti-transitive rootable: RootAble * RootAble

  /**
   * Whether a type can be emited to CSS
   */
  reflexive, anti-symmetric, transitive cssable: Type * CSSAble {
    ListT(+cssable),
    [+cssable]
  }

rules
  
  init ^ (scriptS) :=
    new scriptS,
    FloatT()  <cssable! CSSAble(),
    IntT()    <cssable! CSSAble(),
    BoolT()   <cssable! CSSAble(),
    ColourT() <cssable! CSSAble(),
    StringT() <cssable! CSSAble(),
    
    FloatT()  <coerce! StringT(),
    NullT()   <coerce! StringT(), // emptystring
    BoolT()   <coerce! StringT(),
    ColourT() <coerce! StringT(),
    IntT()    <coerce! FloatT(),
    
    NullT()   <coerce! BoolT(), // false
    // everything else transitively through StringT, true
    StringT() <coerce! BoolT(). 
  
  [[ Script(items) ^ (s) ]] :=
    RootScopeIterative[[ items ^ (s) ]].
 
  /**
   * RootScopeIterative iteratively builds a scope chain at the root of a script. The 
   * scope variable contains the scope node available at the evaluation of the 
   * current AST node.
   */
  RootScopeIterative[[ [] ^ (_) ]].
  
  /**
   * ScopeIterative iteratively builds a scope graph. The scope variable contains:
   *  - The available scope
   *  - The last global scope node
   *  - The global scope that should be linked to the last global scope defined in the block.
   *      This allows nested blocks to define global variables that are available in later
          blocks and script elements.
   */
  ScopeIterative[[ [] ^ (_, nGS, finalGS, rootableCheck) ]] :=
    finalGS -G-> nGS,
    rootableCheck == RootAble().
    